// server/index.ts
import express2 from "express";

// server/routes.ts
import { createServer } from "http";

// server/database.ts
import { drizzle } from "drizzle-orm/neon-http";
import { neon } from "@neondatabase/serverless";
import { eq, desc, asc, and, gte, lte, like, or, sql } from "drizzle-orm";

// shared/schema.ts
import { pgTable, text, serial, integer, boolean, timestamp } from "drizzle-orm/pg-core";
import { createInsertSchema } from "drizzle-zod";
var venues = pgTable("venues", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  address: text("address").notNull(),
  website: text("website"),
  description: text("description"),
  capacity: integer("capacity"),
  imageUrl: text("image_url")
});
var events = pgTable("events", {
  id: serial("id").primaryKey(),
  title: text("title").notNull(),
  description: text("description"),
  venueId: integer("venue_id").references(() => venues.id).notNull(),
  startDate: timestamp("start_date").notNull(),
  endDate: timestamp("end_date"),
  startTime: text("start_time"),
  endTime: text("end_time"),
  price: text("price"),
  ticketUrl: text("ticket_url"),
  genre: text("genre"),
  ageRestriction: text("age_restriction"),
  isFeatured: boolean("is_featured").default(false),
  isSoldOut: boolean("is_sold_out").default(false),
  imageUrl: text("image_url"),
  artistInfo: text("artist_info"),
  status: text("status").default("upcoming")
  // upcoming, past, cancelled
});
var artists = pgTable("artists", {
  id: serial("id").primaryKey(),
  name: text("name").notNull(),
  genre: text("genre"),
  description: text("description"),
  website: text("website"),
  imageUrl: text("image_url")
});
var eventArtists = pgTable("event_artists", {
  id: serial("id").primaryKey(),
  eventId: integer("event_id").references(() => events.id).notNull(),
  artistId: integer("artist_id").references(() => artists.id).notNull(),
  isHeadliner: boolean("is_headliner").default(false)
});
var insertVenueSchema = createInsertSchema(venues).omit({
  id: true
});
var insertEventSchema = createInsertSchema(events).omit({
  id: true
});
var insertArtistSchema = createInsertSchema(artists).omit({
  id: true
});
var insertEventArtistSchema = createInsertSchema(eventArtists).omit({
  id: true
});

// server/database.ts
var connectionString = process.env.DATABASE_URL;
var sql_client = neon(connectionString);
var db = drizzle(sql_client);
var DatabaseStorage = class {
  // Venue methods
  async getVenue(id) {
    const result = await db.select().from(venues).where(eq(venues.id, id)).limit(1);
    return result[0];
  }
  async getVenueByName(name) {
    const result = await db.select().from(venues).where(eq(venues.name, name)).limit(1);
    return result[0];
  }
  async getAllVenues() {
    return await db.select().from(venues).orderBy(asc(venues.name));
  }
  async getVenuesWithEvents() {
    const venueList = await this.getAllVenues();
    const venuesWithEvents = [];
    for (const venue of venueList) {
      const upcomingEvents = await this.getEventsByVenue(venue.id);
      venuesWithEvents.push({
        ...venue,
        upcomingEvents,
        eventCount: upcomingEvents.length
      });
    }
    return venuesWithEvents;
  }
  async createVenue(venue) {
    const result = await db.insert(venues).values(venue).returning();
    return result[0];
  }
  // Event methods
  async getEvent(id) {
    const result = await db.select().from(events).where(eq(events.id, id)).limit(1);
    return result[0];
  }
  async getAllEvents() {
    return await db.select().from(events).orderBy(desc(events.startDate));
  }
  async getEventsByVenue(venueId) {
    return await db.select().from(events).where(eq(events.venueId, venueId)).orderBy(desc(events.startDate));
  }
  async getEventsByDateRange(startDate, endDate) {
    return await db.select().from(events).where(and(
      gte(events.startDate, startDate),
      lte(events.startDate, endDate)
    )).orderBy(desc(events.startDate));
  }
  async getUpcomingEvents(limit) {
    const now = /* @__PURE__ */ new Date();
    if (limit) {
      return await db.select().from(events).where(gte(events.startDate, now)).orderBy(desc(events.startDate)).limit(limit);
    }
    return await db.select().from(events).where(gte(events.startDate, now)).orderBy(desc(events.startDate));
  }
  async getFeaturedEvents() {
    return await db.select().from(events).where(eq(events.isFeatured, true)).orderBy(desc(events.startDate));
  }
  async getEventsThisWeek() {
    const now = /* @__PURE__ */ new Date();
    const weekStart = new Date(now);
    weekStart.setDate(now.getDate() - now.getDay());
    weekStart.setHours(0, 0, 0, 0);
    const weekEnd = new Date(weekStart);
    weekEnd.setDate(weekStart.getDate() + 6);
    weekEnd.setHours(23, 59, 59, 999);
    const eventsList = await db.select({
      event: events,
      venue: venues
    }).from(events).innerJoin(venues, eq(events.venueId, venues.id)).where(and(
      gte(events.startDate, weekStart),
      lte(events.startDate, weekEnd)
    )).orderBy(desc(events.startDate));
    return eventsList.map((row) => ({
      ...row.event,
      venue: row.venue
    }));
  }
  async getEventsByGenre(genre) {
    return await db.select().from(events).where(eq(events.genre, genre)).orderBy(desc(events.startDate));
  }
  async searchEvents(query) {
    const searchTerm = `%${query.toLowerCase()}%`;
    const eventsList = await db.select({
      event: events,
      venue: venues
    }).from(events).innerJoin(venues, eq(events.venueId, venues.id)).where(or(
      like(sql`LOWER(${events.title})`, searchTerm),
      like(sql`LOWER(${events.description})`, searchTerm),
      like(sql`LOWER(${events.genre})`, searchTerm),
      like(sql`LOWER(${events.artistInfo})`, searchTerm)
    )).orderBy(desc(events.startDate));
    return eventsList.map((row) => ({
      ...row.event,
      venue: row.venue
    }));
  }
  async createEvent(event) {
    const result = await db.insert(events).values(event).returning();
    return result[0];
  }
  async updateEvent(id, event) {
    const result = await db.update(events).set(event).where(eq(events.id, id)).returning();
    return result[0];
  }
  async getEventsWithVenue() {
    const eventsList = await db.select({
      event: events,
      venue: venues
    }).from(events).innerJoin(venues, eq(events.venueId, venues.id)).orderBy(desc(events.startDate));
    return eventsList.map((row) => ({
      ...row.event,
      venue: row.venue
    }));
  }
  // Artist methods
  async getArtist(id) {
    const result = await db.select().from(artists).where(eq(artists.id, id)).limit(1);
    return result[0];
  }
  async getAllArtists() {
    return await db.select().from(artists).orderBy(asc(artists.name));
  }
  async createArtist(artist) {
    const result = await db.insert(artists).values(artist).returning();
    return result[0];
  }
  async getArtistsByEvent(eventId) {
    const result = await db.select({
      artist: artists
    }).from(eventArtists).innerJoin(artists, eq(eventArtists.artistId, artists.id)).where(eq(eventArtists.eventId, eventId));
    return result.map((row) => row.artist);
  }
  // Event-Artist relationship methods
  async addArtistToEvent(eventArtist) {
    const result = await db.insert(eventArtists).values(eventArtist).returning();
    return result[0];
  }
  async removeArtistFromEvent(eventId, artistId) {
    const result = await db.delete(eventArtists).where(and(
      eq(eventArtists.eventId, eventId),
      eq(eventArtists.artistId, artistId)
    ));
    return result.rowCount > 0;
  }
  // Cleanup methods
  async clearAllEvents() {
    await db.delete(events);
  }
  async clearOldEvents(daysOld = 30) {
    const cutoffDate = /* @__PURE__ */ new Date();
    cutoffDate.setDate(cutoffDate.getDate() - daysOld);
    await db.delete(events).where(lte(events.startDate, cutoffDate));
  }
};

// server/storage.ts
var storage = new DatabaseStorage();

// server/scheduler.ts
import cron from "node-cron";

// server/scrapers.ts
import axios from "axios";
import * as cheerio from "cheerio";
var VenueScraper = class {
  async fetchPage(url) {
    try {
      const response = await axios.get(url, {
        headers: {
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
        },
        timeout: 1e4
      });
      return response.data;
    } catch (error) {
      console.error(`Failed to fetch ${url}:`, error);
      throw error;
    }
  }
  parseDate(dateStr) {
    const cleanDate = dateStr.replace(/[^\w\s,]/g, "").trim();
    const patterns = [
      /(\w+),?\s+(\w+)\s+(\d{1,2})/i,
      // "Fri, June 27" or "Friday June 27"
      /(\w+)\s+(\d{1,2}),?\s+(\d{4})/i,
      // "June 27, 2025"
      /(\d{1,2})\/(\d{1,2})\/(\d{4})/i
      // "6/27/2025"
    ];
    for (const pattern of patterns) {
      const match = cleanDate.match(pattern);
      if (match) {
        try {
          return new Date(cleanDate);
        } catch {
          continue;
        }
      }
    }
    const currentYear = (/* @__PURE__ */ new Date()).getFullYear();
    return /* @__PURE__ */ new Date(`${cleanDate} ${currentYear}`);
  }
  async scrapeOrangePeel() {
    console.log("Scraping The Orange Peel...");
    const events2 = [];
    try {
      const html = await this.fetchPage("https://theorangepeel.net/events/");
      const $ = cheerio.load(html);
      $(".event-item, .tribe-events-calendar-list__event").each((_, element) => {
        const $event = $(element);
        const title = $event.find(".event-title, .tribe-events-calendar-list__event-title a").text().trim();
        const dateText = $event.find(".event-date, .tribe-events-calendar-list__event-date-tag").text().trim();
        const description = $event.find(".event-description, .tribe-events-calendar-list__event-description").text().trim();
        const price = $event.find(".event-cost, .tribe-events-cost").text().trim();
        const ticketUrl = $event.find('a[href*="etix"], a[href*="ticket"]').attr("href");
        if (title && dateText) {
          events2.push({
            title,
            description: description || void 0,
            date: dateText,
            price: price || void 0,
            ticketUrl: ticketUrl || void 0,
            genre: "Music",
            ageRestriction: "Ages 18+"
          });
        }
      });
    } catch (error) {
      console.error("Error scraping Orange Peel:", error);
    }
    return events2;
  }
  async scrapeGreyEagle() {
    console.log("Scraping The Grey Eagle...");
    const events2 = [];
    try {
      const html = await this.fetchPage("https://www.thegreyeagle.com/calendar/");
      const $ = cheerio.load(html);
      $(".event-item, .tribe-events-calendar-list__event").each((_, element) => {
        const $event = $(element);
        const title = $event.find("h3 a, .event-title a").text().trim();
        const dateText = $event.find(".event-date, .tribe-events-calendar-list__event-date-tag").text().trim();
        const description = $event.find(".event-description").text().trim();
        const price = $event.find(".event-cost").text().trim();
        const ticketUrl = $event.find('a[href*="etix"], a[href*="ticket"]').attr("href");
        if (title && dateText) {
          events2.push({
            title,
            description: description || void 0,
            date: dateText,
            price: price || void 0,
            ticketUrl: ticketUrl || void 0,
            genre: "Music"
          });
        }
      });
    } catch (error) {
      console.error("Error scraping Grey Eagle:", error);
    }
    return events2;
  }
  async scrapeAshevilleMusicHall() {
    console.log("Scraping Asheville Music Hall...");
    const events2 = [];
    try {
      const html = await this.fetchPage("https://ashevillemusichall.com/all-shows/");
      const $ = cheerio.load(html);
      $(".event-item, .tribe-events-calendar-list__event").each((_, element) => {
        const $event = $(element);
        const title = $event.find("h3 a, .event-title a").text().trim();
        const dateText = $event.find(".event-date, .tribe-events-calendar-list__event-date-tag").text().trim();
        const description = $event.find(".event-description").text().trim();
        const ticketUrl = $event.find('a[href*="etix"], a[href*="ticket"]').attr("href");
        if (title && dateText) {
          events2.push({
            title,
            description: description || void 0,
            date: dateText,
            ticketUrl: ticketUrl || void 0,
            genre: "Music"
          });
        }
      });
    } catch (error) {
      console.error("Error scraping Asheville Music Hall:", error);
    }
    return events2;
  }
  async scrapeOneWorldBrewing() {
    console.log("Scraping One World Brewing...");
    const events2 = [];
    try {
      const html = await this.fetchPage("https://oneworldbrewing.com/events/");
      const $ = cheerio.load(html);
      $(".event-item, .tribe-events-calendar-list__event").each((_, element) => {
        const $event = $(element);
        const title = $event.find("h3 a, .event-title a").text().trim();
        const dateText = $event.find(".event-date, .tribe-events-calendar-list__event-date-tag").text().trim();
        const description = $event.find(".event-description").text().trim();
        if (title && dateText) {
          events2.push({
            title,
            description: description || void 0,
            date: dateText,
            genre: "Live Music"
          });
        }
      });
    } catch (error) {
      console.error("Error scraping One World Brewing:", error);
    }
    return events2;
  }
  async saveEventsToDatabase(events2, venueName) {
    const venue = await storage.getVenueByName(venueName);
    if (!venue) {
      console.error(`Venue not found: ${venueName}`);
      return;
    }
    for (const scrapedEvent of events2) {
      try {
        const eventDate = this.parseDate(scrapedEvent.date);
        const existingEvents = await storage.getEventsByVenue(venue.id);
        const isDuplicate = existingEvents.some(
          (existing) => existing.title === scrapedEvent.title && Math.abs(new Date(existing.startDate).getTime() - eventDate.getTime()) < 24 * 60 * 60 * 1e3
        );
        if (!isDuplicate) {
          const newEvent = {
            title: scrapedEvent.title,
            description: scrapedEvent.description || null,
            venueId: venue.id,
            startDate: eventDate,
            endDate: null,
            startTime: scrapedEvent.time || null,
            endTime: null,
            price: scrapedEvent.price || null,
            ticketUrl: scrapedEvent.ticketUrl || null,
            genre: scrapedEvent.genre || null,
            ageRestriction: scrapedEvent.ageRestriction || null,
            isFeatured: false,
            isSoldOut: scrapedEvent.price?.toLowerCase().includes("sold out") || false,
            imageUrl: scrapedEvent.imageUrl || null,
            artistInfo: scrapedEvent.artistInfo || null,
            status: "upcoming"
          };
          await storage.createEvent(newEvent);
          console.log(`Added event: ${scrapedEvent.title} at ${venueName}`);
        }
      } catch (error) {
        console.error(`Error saving event ${scrapedEvent.title}:`, error);
      }
    }
  }
  async scrapeAllVenues() {
    console.log("Starting venue scraping...");
    try {
      const [orangePeelEvents, greyEagleEvents, musicHallEvents, oneWorldEvents] = await Promise.allSettled([
        this.scrapeOrangePeel(),
        this.scrapeGreyEagle(),
        this.scrapeAshevilleMusicHall(),
        this.scrapeOneWorldBrewing()
      ]);
      if (orangePeelEvents.status === "fulfilled") {
        await this.saveEventsToDatabase(orangePeelEvents.value, "The Orange Peel");
      }
      if (greyEagleEvents.status === "fulfilled") {
        await this.saveEventsToDatabase(greyEagleEvents.value, "The Grey Eagle");
      }
      if (musicHallEvents.status === "fulfilled") {
        await this.saveEventsToDatabase(musicHallEvents.value, "Asheville Music Hall");
      }
      if (oneWorldEvents.status === "fulfilled") {
        await this.saveEventsToDatabase(oneWorldEvents.value, "One World Brewing");
      }
      console.log("Venue scraping completed successfully");
    } catch (error) {
      console.error("Error during venue scraping:", error);
    }
  }
};

// server/scheduler.ts
var EventScheduler = class {
  scraper;
  isRunning = false;
  constructor() {
    this.scraper = new VenueScraper();
  }
  async updateEvents() {
    if (this.isRunning) {
      console.log("Event update already in progress, skipping...");
      return;
    }
    this.isRunning = true;
    console.log(`[${(/* @__PURE__ */ new Date()).toISOString()}] Starting daily event update...`);
    try {
      await this.cleanupOldEvents();
      await this.scraper.scrapeAllVenues();
      console.log(`[${(/* @__PURE__ */ new Date()).toISOString()}] Daily event update completed successfully`);
    } catch (error) {
      console.error(`[${(/* @__PURE__ */ new Date()).toISOString()}] Error during daily event update:`, error);
    } finally {
      this.isRunning = false;
    }
  }
  async cleanupOldEvents() {
    console.log("Cleaning up old events...");
    try {
      const allEvents = await storage.getAllEvents();
      const thirtyDaysAgo = /* @__PURE__ */ new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);
      const eventsToUpdate = allEvents.filter(
        (event) => new Date(event.startDate) < thirtyDaysAgo && event.status !== "past"
      );
      for (const event of eventsToUpdate) {
        await storage.updateEvent(event.id, { status: "past" });
      }
      console.log(`Updated ${eventsToUpdate.length} events to past status`);
    } catch (error) {
      console.error("Error cleaning up old events:", error);
    }
  }
  startScheduler() {
    console.log("Starting event update scheduler...");
    cron.schedule("0 6 * * *", async () => {
      await this.updateEvents();
    });
    cron.schedule("0 */6 * * *", async () => {
      await this.updateEvents();
    });
    console.log("Event scheduler started - updates will run daily at 6:00 AM and every 6 hours");
    setTimeout(async () => {
      console.log("Running initial event update...");
      await this.updateEvents();
    }, 3e4);
  }
  stopScheduler() {
    console.log("Event scheduler stopped");
  }
  // Manual trigger for testing or immediate updates
  async triggerUpdate() {
    console.log("Manually triggering event update...");
    await this.updateEvents();
  }
  getStatus() {
    return {
      isRunning: this.isRunning,
      nextRun: "Scheduled for daily at 6:00 AM and every 6 hours"
    };
  }
};
var eventScheduler = new EventScheduler();

// server/routes.ts
async function registerRoutes(app2) {
  app2.get("/api/venues", async (req, res) => {
    try {
      const venues2 = await storage.getAllVenues();
      res.json(venues2);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch venues" });
    }
  });
  app2.get("/api/venues/with-events", async (req, res) => {
    try {
      const venuesWithEvents = await storage.getVenuesWithEvents();
      res.json(venuesWithEvents);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch venues with events" });
    }
  });
  app2.get("/api/venues/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const venue = await storage.getVenue(id);
      if (!venue) {
        return res.status(404).json({ message: "Venue not found" });
      }
      res.json(venue);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch venue" });
    }
  });
  app2.get("/api/venues/:id/events", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const events2 = await storage.getEventsByVenue(id);
      res.json(events2);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch venue events" });
    }
  });
  app2.get("/api/events", async (req, res) => {
    try {
      const { genre, venue, startDate, endDate, search } = req.query;
      let events2;
      if (search) {
        events2 = await storage.searchEvents(search);
      } else if (startDate && endDate) {
        const allEvents = await storage.getEventsByDateRange(
          new Date(startDate),
          new Date(endDate)
        );
        events2 = await Promise.all(allEvents.map(async (event) => {
          const venueData = await storage.getVenue(event.venueId);
          return { ...event, venue: venueData };
        }));
      } else {
        events2 = await storage.getEventsWithVenue();
      }
      if (genre && genre !== "all") {
        events2 = events2.filter(
          (event) => event.genre?.toLowerCase() === genre.toLowerCase()
        );
      }
      if (venue && venue !== "all") {
        events2 = events2.filter(
          (event) => event.venue.name.toLowerCase().includes(venue.toLowerCase())
        );
      }
      res.json(events2);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch events" });
    }
  });
  app2.get("/api/events/this-week", async (req, res) => {
    try {
      const events2 = await storage.getEventsThisWeek();
      res.json(events2);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch this week's events" });
    }
  });
  app2.get("/api/events/upcoming", async (req, res) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit) : void 0;
      const events2 = await storage.getUpcomingEvents(limit);
      res.json(events2);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch upcoming events" });
    }
  });
  app2.get("/api/events/featured", async (req, res) => {
    try {
      const events2 = await storage.getFeaturedEvents();
      const eventsWithVenue = await Promise.all(events2.map(async (event) => {
        const venue = await storage.getVenue(event.venueId);
        return { ...event, venue };
      }));
      res.json(eventsWithVenue);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch featured events" });
    }
  });
  app2.get("/api/events/calendar/:year/:month", async (req, res) => {
    try {
      const year = parseInt(req.params.year);
      const month = parseInt(req.params.month);
      const startDate = new Date(year, month - 1, 1);
      const endDate = new Date(year, month, 0);
      const events2 = await storage.getEventsByDateRange(startDate, endDate);
      const eventsWithVenue = await Promise.all(events2.map(async (event) => {
        const venue = await storage.getVenue(event.venueId);
        return { ...event, venue };
      }));
      res.json(eventsWithVenue);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch calendar events" });
    }
  });
  app2.get("/api/events/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const event = await storage.getEvent(id);
      if (!event) {
        return res.status(404).json({ message: "Event not found" });
      }
      const venue = await storage.getVenue(event.venueId);
      const eventWithVenue = { ...event, venue };
      res.json(eventWithVenue);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch event" });
    }
  });
  app2.get("/api/search", async (req, res) => {
    try {
      const { q } = req.query;
      if (!q) {
        return res.status(400).json({ message: "Search query required" });
      }
      const events2 = await storage.searchEvents(q);
      res.json(events2);
    } catch (error) {
      res.status(500).json({ message: "Search failed" });
    }
  });
  app2.get("/api/filters", async (req, res) => {
    try {
      const events2 = await storage.getAllEvents();
      const venues2 = await storage.getAllVenues();
      const genres = Array.from(new Set(events2.map((event) => event.genre).filter(Boolean)));
      const venueNames = venues2.map((venue) => venue.name);
      res.json({
        genres,
        venues: venueNames
      });
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch filter options" });
    }
  });
  app2.post("/api/admin/update-events", async (req, res) => {
    try {
      await eventScheduler.triggerUpdate();
      res.json({ message: "Event update triggered successfully" });
    } catch (error) {
      res.status(500).json({ message: "Failed to trigger event update" });
    }
  });
  app2.get("/api/admin/update-status", async (req, res) => {
    try {
      const status = eventScheduler.getStatus();
      res.json(status);
    } catch (error) {
      res.status(500).json({ message: "Failed to get update status" });
    }
  });
  const httpServer = createServer(app2);
  return httpServer;
}

// server/vite.ts
import express from "express";
import fs from "fs";
import path2 from "path";
import { createServer as createViteServer, createLogger } from "vite";

// vite.config.ts
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";
var vite_config_default = defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...process.env.NODE_ENV !== "production" && process.env.REPL_ID !== void 0 ? [
      await import("@replit/vite-plugin-cartographer").then(
        (m) => m.cartographer()
      )
    ] : []
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets")
    }
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true
  },
  server: {
    fs: {
      strict: true,
      deny: ["**/.*"]
    }
  }
});

// server/vite.ts
import { nanoid } from "nanoid";
var viteLogger = createLogger();
function log(message, source = "express") {
  const formattedTime = (/* @__PURE__ */ new Date()).toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true
  });
  console.log(`${formattedTime} [${source}] ${message}`);
}
async function setupVite(app2, server) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server },
    allowedHosts: true
  };
  const vite = await createViteServer({
    ...vite_config_default,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      }
    },
    server: serverOptions,
    appType: "custom"
  });
  app2.use(vite.middlewares);
  app2.use("*", async (req, res, next) => {
    const url = req.originalUrl;
    try {
      const clientTemplate = path2.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html"
      );
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e);
      next(e);
    }
  });
}
function serveStatic(app2) {
  const distPath = path2.resolve(import.meta.dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`
    );
  }
  app2.use(express.static(distPath));
  app2.use("*", (_req, res) => {
    res.sendFile(path2.resolve(distPath, "index.html"));
  });
}

// server/init-database.ts
async function initializeDatabase() {
  console.log("Initializing database with venues...");
  try {
    const existingVenues = await storage.getAllVenues();
    if (existingVenues.length > 0) {
      console.log("Database already initialized with venues");
      return;
    }
    const venues2 = [
      {
        name: "The Orange Peel",
        address: "101 Biltmore Ave, Asheville, NC 28801",
        website: "https://theorangepeel.net",
        description: "Premier music venue in downtown Asheville featuring national and international touring acts.",
        capacity: 1050,
        imageUrl: null
      },
      {
        name: "The Grey Eagle",
        address: "185 Clingman Ave, Asheville, NC 28801",
        website: "https://www.thegreyeagle.com",
        description: "Intimate music venue and tavern in the River Arts District.",
        capacity: 500,
        imageUrl: null
      },
      {
        name: "Asheville Music Hall",
        address: "31 Patton Ave, Asheville, NC 28801",
        website: "https://ashevillemusichall.com",
        description: "Historic music venue in downtown Asheville hosting diverse musical acts.",
        capacity: 800,
        imageUrl: null
      },
      {
        name: "One World Brewing",
        address: "10 Patton Ave, Asheville, NC 28801",
        website: "https://oneworldbrewing.com",
        description: "Brewery and music venue featuring local and touring artists.",
        capacity: 300,
        imageUrl: null
      }
    ];
    for (const venue of venues2) {
      await storage.createVenue(venue);
      console.log(`Created venue: ${venue.name}`);
    }
    console.log("Database initialization completed successfully");
  } catch (error) {
    console.error("Error initializing database:", error);
  }
}

// server/index.ts
var app = express2();
app.use(express2.json());
app.use(express2.urlencoded({ extended: false }));
app.use((req, res, next) => {
  const start = Date.now();
  const path3 = req.path;
  let capturedJsonResponse = void 0;
  const originalResJson = res.json;
  res.json = function(bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };
  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path3.startsWith("/api")) {
      let logLine = `${req.method} ${path3} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }
      if (logLine.length > 80) {
        logLine = logLine.slice(0, 79) + "\u2026";
      }
      log(logLine);
    }
  });
  next();
});
(async () => {
  const server = await registerRoutes(app);
  app.use((err, _req, res, _next) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";
    res.status(status).json({ message });
    throw err;
  });
  if (app.get("env") === "development") {
    await setupVite(app, server);
  } else {
    serveStatic(app);
  }
  const port = 5e3;
  server.listen({
    port,
    host: "0.0.0.0",
    reusePort: true
  }, async () => {
    log(`serving on port ${port}`);
    await initializeDatabase();
    eventScheduler.startScheduler();
  });
})();